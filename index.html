---
---
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style.css">

<link rel="icon" href="images/favicon.ico" type="image/x-icon"/>

<title>Rodolphe Lepigre's webpage</title>
</head>
<body id="page_top" data-spy="scroll" data-target="#main_navbar" data-offset="0">
<nav id="main_navbar" class="navbar fixed-top navbar-expand-lg navbar-dark bg-danger">
  <div class="container">
    <a class="navbar-brand" href="#page_top">Rodolphe Lepigre</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNavDropdown">
      <ul class="navbar-nav ml-auto text-center">
        <li class="nav-item">
          <a class="nav-link" href="#sect_research">Research</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#sect_publications">Publications</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#sect_softwares">Software</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#sect_talks">Talks</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div id="main_contents" class="container">
<!--
<div class="alert alert-danger" role="alert">
  Here are a <a href="files/cv_lepigre.pdf">CV</a> and a <a href="files/research_statement_lepigre.pdf">research statement</a>.
</div>
<div class="alert alert-danger" role="alert">
  I now work at the <a href="https://www.mpi-sws.org">Max Planck Institute for Software Systems</a> in Saarbrücken. My new email address is <a href="mailto:lepigre@mpi-sws.org">lepigre@mpi-sws.org</a>.
</div>
-->

<div class="row">
  <div class="col">
    <p class="text-justify">I am a researcher in computer science, currently working as a postdoctoral researcher at the <a href="https://www.mpi-sws.org">Max Planck Institute for Software Systems</a> in Saarbrücken, in <a href="https://people.mpi-sws.org/~dreyer/">Derek Dreyer</a>'s group. Although my interests are diverse, my main area of expertise is the application of semantic techniques to programming languages and proof assistants. I also make a point of backing my theoretical work with a substantial amount of implementation, for which I developed specific tools and libraries in <a href="https://ocaml.org/">OCaml</a>.</p>
    <p class="text-justify"> Between September 2017 and December 2018, I was a postdoctoral researcher at <a href="https://inria.fr">Inria</a> in the <a href="http://deducteam.gforge.inria.fr">Deducteam</a> project, hosted by the <a href="https://lsv.fr">LSV</a> at <a href="http://ens-paris-saclay.fr">ENS Cachan</a> (now ENS Paris-Saclay). During that time, I proposed a new implementation of the <a href="https://deducteam.github.io">Dedukti</a> logical framework called <a href="https://github.com/Deducteam/lambdapi">Lambdapi</a>, which enables the development of mathematical proofs in the system, while the original Dedukti was only usable as the target of translations.</p>
    <p class="text-justify">Between October 2014 and August 2017, I was a PhD student at the <a href="https://lama.univ-smb.fr">LAMA</a> (LAboratoire de MAthématiques), in Chambéry (in the French Alps). During that time, I mainly worked with <a href="https://www.lama.univ-savoie.fr/~raffalli">Christophe Raffalli</a> and <a href="https://www.lama.univ-savoie.fr/~hyvernat">Pierre Hyvernat</a>, although my official advisor was <a href="https://www.lama.univ-savoie.fr/~nour">Karim Nour</a>. In my thesis work, I designed the theoretical foundation of (and implemented) the PML₂ language, which mixes programming and program certification in a uniform (ML-like) setting.</p>
    <p>
      <a href="mailto:lepigre@mpi-sws.org" class="fa fa-at"></a>
      <a href="https://github.com/rlepigre" class="fa fa-github"></a>
      <a href="https://gitlab.com/rlepigre" class="fa fa-gitlab"></a>
      <a href="https://gitlab.mpi-sws.org/lepigre" class="fa fa-gitlab"></a>
    </p>
  </div>
  <div class="col-md-auto">
    <img class="border border-dark rounded-circle" src="images/me.png" alt="Rodolphe Lepigre">
  </div>
</div>

<h2 id="sect_research">Research</h2>

<p class="text-justify">Since I joined Derek Dreyer's group at MPI-SWS, I have been spending a lot of time working with (and also on) <a href="https://iris-project.org">Iris</a>. Iris is a higher-order concurent separation logic, which rougly means that it is a modern form of Hoare logic. In particular, it can be used to mechanically verify tricky concurent programs inside the <a href="https://coq.inria.fr">Coq proof assistant</a>. One of my main projects so far (in collaboration with Ralf Jung, Gaurav Parthasarathy, Marianna Rapoport, Amin Timany, Derek Dreyer and Bart Jacobs) has been to integrate Abadi and Lamport's prophecy variables to the Hoare logic framework <a href="#JLPRTDJ2020">[JLPRTDJ2020]</a>. Prophecy variables turn out to be a very useful mechanism when proving strong (logically atomic) specifications for concurent data structures like RDCSS or the Herlihy-Wing queue.</p>

<p class="text-justify">On a more personal side, my general research project revolves around the design and implementation of PML₂ <a href="#PML2">[PML2]</a>, which is a programming language with support for program certification. The main idea is to extend an ML-like language, similar to OCaml or SML, with the means of specifying and proving equational properties of its own programs. We thus combine the flexibility of a full-fledged programming language with the great specification power of a proof assistant. Although the development of PML₂ is one of my leading goals, it is first and foremost an excuse for attacking difficult theoretical and practical questions. Of course, the answers to such questions go beyond the scope of PML₂, although I often present them in its light. In this sense, the implementation of the language can be seen as an experimentation platform for driving theoretical investigations. I strongly believe that mixing abstract theoretical questions with pragmatic implementation aspects mutually benefits to both fields. For example, the type system given in <a href="#Lepigre2016">[Lepigre2016]</a> could not be implemented in a natural way due to the fact that PML₂ is a so-called Curry-style language. As a result, we developed a new framework for dealing with such languages, including new techniques using subtyping, choice operators and circular proofs <a href="#LepRaf2019">[LepRaf2019]</a>.</p>

<p class="text-justify">Since a previous postdoctoral research position at Inria, I am involved in an effort to transform the <a href="https://deducteam.github.io">Dedukti</a> logical framework into a full-fledged, interactive proof system. This new line of work around Dedukti was envisioned by <a href="http://rewriting.gforge.inria.fr">Frédéric Blanqui</a>, and it is now based on the new implementation of the λΠ-calculus that I initiated <a href="#Lambdapi">[Lambdapi]</a>. This new implementation has several major advantages over the previous version of Dedukti. First and foremost, it provides a primitive notion of metavariable which is used for representing proof goals as well as omitted elements (e.g., implicit arguments). Moreover, the implementation relies on the Bindlib library <a href="#Bindlib">[Bindlib]</a>, which allows for high-level manipulations of structures with bound variables without sacrificing efficiency.</p>

<h4>Classical realizability and observational equivalence</h4>

<p class="text-justify">To prove the correctness of the PML₂ system (logical consistency and runtime safety), I designed a theoretical framework based on Krivine's classical realisability <a href="#Lepigre2016">[Lepigre2016]</a>. This semantical model accounts for the specificities of the system, and in particular the notion of program equivalence that is used for specifying computational behaviours. I thus defined a relation of observational equivalence over terms, which can be naturally expressed in the classical realizability settings. Indeed, quantifying over all the evaluation contexts simply amounts to quantifying over all the stacks in a Krivine abstract machine. Another specificity of the model lies in its call-by-value nature, which yields an interpretation with three layers, against two in the usual (call-by-name) presentation of Krivine's classical realizability (this was already noticed by Guillaume Munch-Maccagnoni). Indeed, a type <span class="maths">A</span> is interpreted by a set of (fully-evaluated) values <span class="maths">⟦A⟧</span>, a set of stack (evaluation contexts), and a set of terms <span class="maths">⟦A⟧<sup>⊥⊥</sup></span> linked by an orthogonality relation. In some sense, this means that <span class="maths">⟦A⟧<sup>⊥⊥</sup></span> is the completion of <span class="maths">⟦A⟧</span> with terms computing elements of <span class="maths">⟦A⟧</span>. It is essential for these sets to be closed under observational equivalence.</p>

<h4>Dependent functions, effects and value restriction</h4>

<p class="text-justify">In PML₂, program properties are specified and proved by manipulating terms as the first-order objects of the type system. In particular, this gives a way of expressing properties that should hold for all terms. For example, we can write <span class="maths">∀n, ∀m, n+m ≡ m+n</span> to express the commutativity of an addition function. However, the first-order quantification that is used here ranges over every possible values, without any type consideration. Whereas functions like addition are usually not defined on all values, but on a restricted domain like the natural numbers, and may crash when fed with something else. Hence, we often need to rely on a stronger, typed form of quantification, with which we can write <span class="maths">∀n∈ℕ, ∀m∈ℕ, n+m ≡ m+n</span>. Such types correspond to a form of dependent function. For instance, the previous example is inhabited by functions taking two number <span class="maths">x</span> and <span class="maths">y</span>, and returning a proof of <span class="maths">x+y ≡ y+x</span>. In PML₂, working with such dependent function types is delicate because of the presence of effects. Indeed, as for polymorphism in ML, dependent functions require some restriction to preserve soundness. The usual <em>value restriction</em> used in ML also applies here, but it is not satisfactory. Indeed, it restricts the application of dependent function to values, which breaks the compositionality of the system.</p>

<p class="text-justify">To solve this issue, I proposed to relax value restriction using the idea that a term that is (observationally) equivalent to a value can be considered to be a value <a href="#Lepigre2016">[Lepigre2016]</a>. Although this so-called <em>semantical value restriction</em> is simple, it is extremely hard to justify in the model. Indeed, it requires an essential property relating the different levels of interpretation of types in a novel way. As mentioned previously, a type <span class="maths">A</span> is interpreted both as a set of values <span class="maths">⟦A⟧</span> and as a set of terms <span class="maths">⟦A⟧<sup>⊥⊥</sup></span> defined as a completion of <span class="maths">⟦A⟧</span>, which implies <span class="maths">⟦A⟧ ⊆ ⟦A⟧<sup>⊥⊥</sup></span>. The property that is required for justifying the semantical value restriction is the following: every value of <span class="maths">⟦A⟧<sup>⊥⊥</sup></span> should already be in <span class="maths">⟦A⟧</span>. In other words, the completion operation on sets of values should be closed for values. To obtain this property, I extended the programming language with a new instruction, which provides new tests for observational equivalence (see <a href="#Lepigre2016">[Lepigre2016]</a> and <a href="#Lepigre2017PhD">[Lepigre2017PhD]</a>).</p>

<h4>Type-checking and subtyping in Curry-style languages</h4>

<p class="text-justify">Type checking (verifying that a given term inhabits a given type) and type inference (finding a type that is inhabited by a given term) tend to be undecidable in Curry-style languages like System F or PML₂. As a consequence, these system are sometimes considered impractical, although practicality and decidability are two different problems. The main issue with Curry-style languages is that their type systems are generally not syntax-directed, meaning that they cannot be easily implemented. In particular, there is no canonical way of deciding what typing rule should be applied first when attempting to prove a typing judgment. To solve this problem, we designed (with Christophe Raffalli) a framework based on subtyping <a href="#LepRaf2019">[LepRaf2019]</a>. The main, innovating idea is to use a ternary relation <span class="maths">t ∈ A ⊆ B</span> instead of the usual binary relation <span class="maths">A ⊆ B</span>. We interpret the former as the implication “if the term <span class="maths">t</span> has type <span class="maths">A</span>, then it also has type <span class="maths">B</span>”, while the latter is interpreted as the inclusion “every element of type <span class="maths">A</span> is an element of type <span class="maths">B</span>”. In the obtained system, only one typing rule applies for every term constructor, and only one subtyping rule applies for every pair of types (up to commutation). In particular, the connectives that do not have algorithmic contents (those that are not reflected in the syntax of the terms) are handled using subtyping exclusively. Such connectives include the quantifiers, but also the equality types of PML₂ and the least and greatest fixpoint constructors used by inductive and coinductive types.</p>

<h4>Choice operators for a closed semantics</h4>

<p class="text-justify">Our work on Curry-style languages <a href="#LepRaf2019">[LepRaf2019]</a> not only involves a new notion of subtyping, but also a new way of dealing with variables based on choice operators, inspired by Hilbert's Epsilon operator. With this new presentation, bound variables are systematically substituted by closed symbols playing the role of witnesses for semantical properties. As a consequence, terms and types remain closed throughout the typing and subtyping rules, and the usual typing contexts are not requires anymore. This presentation has several advantages, the first of which being a simplification of the semantics. Indeed, free variables are usually handled (in realizability models) using so-called valuations, assigning them a semantic value. In our presentation, such maps are not required since all the necessary information is carried by the symbolic witnesses that are substituted to free variables. As an indirect consequence of this technique, structural rules such as weakening become completely transparent, and implementation only requires first-order unification. Finally, the elimination of contexts facilitates the construction of circular proofs (see below).</p>

<h4>Circular proofs and termination checking</h4>

<p class="text-justify">As mentioned earlier, the framework based on subtyping developed in <a href="#LepRaf2019">[LepRaf2019]</a> is compatible with inductive and coinductive types. They are added to the syntax of types in the form of least and greatest fixpoint operators, which are annotated by ordinals to form sized-types. To handle these constructors in a sound way, we introduce a notion of circular proof with a related well-foundedness criterion. In particular, the subtyping rules that are given for the fixed points induce a form of infinite unfolding. This is due to the fact that we work with symbolic ordinals that are not given a concrete value, and it is thus impossible to know when the zero ordinal will be reached in a decreasing sequence. However, assuming that the proof is well-founded, we know that it will indeed be reached after finitely many unfolding steps. To keep the proof representation finite, we introduce circularity in our proofs, and check that they are well-formed using the size-change principle of Lee, Jones and Ben Amram. The notion of circular proof that we consider is in fact very general, and can also be applied to typing rules in our context.  This allows us to type recursive programs in a very simple way, while proving their termination. The normalisation proof is obtained using standard reducibility candidates (or realizability) techniques. Indeed, as the structure of our circular proofs is well-founded, it is still possible to reason by (well-founded) induction on the structure of our typing (or subtyping) derivations.</p>

<h2 id="sect_publications">Publications (<a href="https://dblp.uni-trier.de/pers/hd/l/Lepigre:Rodolphe">also on dblp</a>)</h2>

{% for p in site.data.publications %}
<div class="card mb-3" id="{{ p.key }}">
  {% if p.kind != "thesis" %}
  <div class="card-header text-white bg-{{ p.kind }}">
  {% else %}
  <div class="card-header bg-{{ p.kind }}">
  {% endif %}
    <u>{{ p.title }}</u>
    <span class="float-md-right">[{{ p.key }}]</span><br/>
    {{ p.authors | join: ", " }}<br/>
    {{ p.where_published }}
  </div>
  <div class="card-body pb-0">
    <p class="collapse show text-justify" id="collapse_abs_{{ p.key }}">
      <b>Abstract.</b> {{ p.abstract | join: '<br><span class="indent">' }}
    </p>
    <p>
      <a class="btn btn-info" data-toggle="collapse" href="#collapse_abs_{{ p.key }}" role="button" aria-expanded="true" aria-controls="collapse_abs_{{ p.key }}">Abstract</a>
      <a class="btn btn-info" href="{{ p.pdf_url }}" role="button">PDF</a>
      {% if p.dblp_url %}
      <a class="btn btn-info" href="{{ p.dblp_url }}" role="button">On DPLB</a>
      <a class="btn btn-info" href="{{ p.dblp_url }}?view=bibtex&param=0" role="button">Bibtex</a>
      {% endif %}
      {% for u in p.urls %}
      <a class="btn btn-info" href="{{ u.url }}" role="button">{{ u.name }}</a>
      {% endfor %}
    </p>
  </div>
</div>
{% endfor %}

<h2 id="sect_softwares">Software</h2>

<p class="text-justify">My work on the design of type systems for programming languages and proof assistants has resulted in a relatively large amount of implementation work. The most important projects are listed in the following section, and include PML₂ (which is described in <a href="#Lepigre2017">[Lepigre2017]</a> and <a href="#Lepigre2017PhD">[Lepigre2017PhD]</a>), SubML (which is described in <a href="#LepRaf2019">[LepRaf2019]</a>) but also a more recent work on a new implementation and extension of the <a href="https://deducteam.github.io">Dedukti</a> logical framework. The implementation of such systems has also directed me toward the development of specific tools and software libraries providing convenient abstractions. For instance, I take part in the development of the Bindlib library <a href="#LepRaf2018">[LepRaf2018]</a>, that was initiated by Christophe Raffalli, and that provides an abstract representation for binders (which are very common in languages and proofs systems). We also developed (with Christophe Raffalli) a system for writing parsers called Earley, that is integrated to OCaml using a BNF-like syntax extension.</p>

{% for s in site.data.softwares %}
<div class="card mb-3" id="{{ s.key }}">
  <div class="card-header">
    {{ s.title }}
    <span class="float-md-right">[{{ s.key }}]</span>
  </div>
  <div class="card-body pb-0">
    <p class="text-justify">{{ s.descr }}</p>
    <p>
      {% for u in s.urls %}
      <a class="btn btn-info" href="{{ u.url }}" role="button">{{ u.name }}</a>
      {% endfor %}
    </p>
  </div>
</div>
{% endfor %}

<h2 id="sect_talks">Talks and paper presentations</h2>

<!--
<div class="alert alert-warning" role="alert">
  I will give a talk ...
</div>
-->

<div class="table-responsive">
<table class="table table-bordered">
  <thead>
    <tr>
      <th scope="col">Date and location</th>
      <th scope="col">Title and kind of talk</th>
      <th scope="col">Slides and videos</th>
    </tr>
  </thead>
  <tbody>
    {% for t in site.data.talks %}
    <tr>
      <td>{{ t.date }}<br/>{{ t.where }}</td>
      <td>
        <u>{{ t.title }}</u><br/>
        {% if t.paper_presentation %}
        <a href="#{{ t.paper_presentation.paper_key }}">Paper</a> presentation
        at the <a href="{{ t.paper_presentation.conference_url }}">{{ t.paper_presentation.conference_name }}</a>
        {% elsif t.contributed_talk %}
        Contributed talk at the <a href="{{ t.contributed_talk.event_url }}">{{ t.contributed_talk.event_name }}</a>
        {% elsif t.invitation %}
        Invited talk at the <a href="{{ t.invitation.event_url }}">{{ t.invitation.event_name }}</a>
        {% elsif t.seminar %}
        {% if t.seminar.seminar_url %}
        <a href="{{ t.seminar.seminar_url }}">{{ t.seminar.seminar_name }}</a> ({{ t.seminar.institution }})
        {% else %}
        {{ t.seminar.seminar_name }} ({{ t.seminar.institution }})
        {% endif %}
        <!-- TODO -->
        {% elsif t.misc_talk %}
        {{ t.misc_talk }}
        {% endif %}
      </td>
      <td>
        {% for u in t.urls %}
        <a class="btn btn-info" href="{{ u.url }}" role="button">{{ u.name }}</a>
        {% endfor %}
      </td>
    </tr>
    {% endfor %}
  </tbody>
</table>
</div>

</div>

<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="extra.js"></script>
</body>
</html>
